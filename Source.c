#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <locale.h>
#define SIZE 9 //определение размеров игрового поля и самих массивов

int meny(), pravila();
char pole(char A[SIZE][SIZE]);
int read_otv(char B[SIZE][SIZE]);
int proverka(int x, int y, char A[SIZE][SIZE], char B[SIZE][SIZE]);
int proverka_nepreruv(int x, int y, char A[SIZE] [SIZE]);
int lose(int* n), proveka_win(char A[SIZE][SIZE], char B[SIZE][SIZE]), nul_A(char A[SIZE][SIZE]);

int main()
{
    char A[SIZE][SIZE];//массив для вывода начального поля и записи правильных ответов
    char B[SIZE][SIZE];//массив с правильными ответами
    int n=0, q = 0;//определение переменных для цикла и для подсчёта неправильных значений
    read_otv(B);//вызываем функцию для чтения из файла
    
    while (q < 1){ // цикл c предусловием
        switch (meny()){//вывод меню
        case (1):
            pole(A);
            while(n<6){//цикл для ввода координат ответа            
                int x, y;//переменные для координат
                printf("\nВведите координаты клетки\n");
                scanf("%d %d", &x, &y);//считывание введённых коррдинат
                
                if ((proverka(x, y, A, B) == 1) && (proverka_nepreruv(x, y, A) == 1)){//проверка на координаты и непрервность                
                    pole(A);//вывод поля
                    if ((proveka_win(A, B) == 1)){//сравнение эталоном
                        printf("\nВы решили головоломку.\n");//вывод сообщение о верном решение головоломки
                        break;
                    }                    
                }
                else{//если не выполняется не подходит ни одному из прошлых условий
                    if (lose(&n) == 1){//проверка на проигрыш
                        n = 0;//обнуление счётчика ошибок
                        nul_A(A);
                        break;
                    }
                }            
            }
            break;//выход из цикла 
        case 2://условие при выборе 2 пунтка меню
            pravila();//вывод правил
            break;//выход из цикла обратно в меню для выбора
        case 3://условие при выборе 3 пунтка меню
            return 1;//выход из цикла while
        default://условие для ввода значений которых нету в меню
            printf("\nТакого значения нет в меню\n");//вывод о том что данного значения нет в пункте меню
        }
    }
}

int meny() 
{
    int d;
    setlocale(LC_ALL, "RUS");
    printf("\nМеню\n");//заголовок
    printf("1)Играть в игру головолмку Змея\n2)Правила игры\n3)Выйти из игры\n");//пункты меню
    printf("Введите цифру согласно значениям в меню, чтобы выбрать действие:"); 
    scanf("%d", &d);//выбор пунтка в меню
    return d;
}

char pole(char A[SIZE][SIZE])//функция для вывода поля
{
    A[0][0] = '4';
    A[8][8] = '4';

    char stroka[9] = { '1', '6', '1', '4', '3', '4', '3', '4', '7' };//количество закрашенных ячеек в каждой строке
    char stolb[9] = { '6', '4', '4', '3', '3', '7', '1', '4', '1' };//количество закрашенных ячеек в кадом столбцеv
    
    printf("Головоломка Snake\n");//название игры
    printf(" _________________\n");//верхняя граница поля
    for (int i = 0; i < SIZE; i++)//цикла для вывода 
    {
        printf("|");//левая граница 
        for (int j = 0; j < SIZE; j++)//цикл для вывода введённогго значения и правых границ
        {
            if (A[i][j] == '4')//проверка на соотвествие условию
            {
                printf("%c|", 4);//вывод в таблице нужного символа
            }
            else
            {
                A[i][j] = '_';
                printf("%c|", A[i][j]);//условие не выполнилось значит ячейка остаётся "пустой"
            }

        }
        printf("%c", stroka[i]);//вывод количества закрашенных ячеек слева таблицы после кждой строки
        printf("\n");//переход на новую строку
    }
    for (int i = 0; i < SIZE; i++)//цикл для вывода 
    {
        printf(" %c", stolb[i]);//вывод количества закрашенных ячеек в столбце
    }
    return 0;
}

int pravila()//функция для вывода правил
{
    printf("\nПравила\nЗмея («Snake») - разновидность логической головоломки.\nЗадание представляет собой прямоугольную или квадратную сетку, внутри которой указаны начальная и конечная точки «змеи».\nНеобходимо закрасить черным цветом некоторые клетки таким образом, чтобы они образовали непрерывную линию между точками.\n«Змея» не может касаться сама себя, даже по диагонали.\nЧисла по бокам сетки показывают, сколько черных клеток находится в соответствующем ряду и столбце сетки.\n");
    //вывод правил игры
    return 0;
}

int read_otv(char B[SIZE][SIZE])//функция для чтения из файла и записи 
{
    setlocale(LC_ALL, "RUS");
    FILE* file = fopen("otv.txt", "r");//открываем файл для чтения

    if (file == NULL)//проверяем успешно ли открыт файл
    {
        printf("Не удалось открыть файл\n");
        return;
    }
    //считываем символы из файла и записываем их в массив B
    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            fscanf(file, " %c", &B[i][j]);//считываем символ из файла в массив B
        }
    }
    fclose(file);//закрываем файл после чтения
    return 0;
}

int proverka(int x, int y, char A[SIZE][SIZE], char B[SIZE][SIZE])
{
    A[x][y] = '4';
    if (A[x][y] == B[x][y])//проверка введённых координат
    {

        return 1;
    }

    else
    {
        A[x][y] = '_';
        return 0;
    }

}

int proverka_nepreruv(int x, int y, char A[SIZE][SIZE])
{
    //проверка на касание себя по всем направлениям, включая диагонали
    if (
        (x > 0 && A[x - 1][y] == '4') ||//вверх
        (x < SIZE - 1 && A[x + 1][y] == '4') ||//вниз
        (y > 0 && A[x][y - 1] == '4') ||//влево
        (y < SIZE - 1 && A[x][y + 1] == '4')//вправо
        ) {
        return 1;  //координаты касаются себя
    }
    else {
        A[x][y] = '_';
        return 0;  //координаты не касаются себя
    }
}

int lose(int* n) 
{
    printf("Введены неверные координаты\n"); //сообщение о неправильности введённых координат
    
    (*n)++;

    printf("Количество ошибок %d из 6\n", *n); //вывод количества ошибок и сколько можно допустить всего

    if (*n == 6) //условие для завершения игры из-за превышения допустимого количетсва ошибок
    {
        printf("Проиграли.\nПопробуйте ещё раз\n"); //вывод о нерешение головоломки
        *n = 0;
        return 1;
    }
    return 0;
}

int proveka_win(char A[SIZE][SIZE], char B[SIZE][SIZE])
{
    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            if (A[i][j] != B[i][j])
            {
                return 0; //значения массивов различны
            }
        }
    }
    return 1; //значения массивов одинаковы
}

int nul_A(char A[SIZE][SIZE]) 
{
    for (int i = 0; i < SIZE; i++) 
    {
        for (int j = 0; j < SIZE; j++) 
        {
            A[i][j] = '0'; //заполняем каждый элемент массива A нулем
        }
    }
    return 0;
}